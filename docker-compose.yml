# docker-compose.yml
# This file defines the services for our multi-app setup:
# - nginx: The reverse proxy server.
# - app1: The first Flask application.
# - app2: The second Flask application.
# All services communicate over a custom Docker network.
version: '3.8'

services:
  nginx:
    # Use the official Nginx image
    image: nginx:latest
    # Map port 80 on the host to port 80 in the container
    ports:
      - "80:80"
    # Mount our custom nginx.conf file into the container
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    # Ensure Flask apps are running before Nginx starts
    depends_on:
      - app1
      - app2
    # Assign Nginx to our custom network
    networks:
      - webapp_network

  app1:
      # Build the image from the Dockerfile in the ./app1 directory
      build:
        context: ./app1
        dockerfile: Dockerfile
      # Expose port 5000 internally for Nginx to access
      expose:
        - "5000"
      # Assign app1 to our custom network
      networks:
        - webapp_network
      # Optional: Uncomment for Flask development server debugging, though Gunicorn is preferred for production-like setups
      # environment:
      #   FLASK_ENV: development

  app2:
    # Build the image from the Dockerfile in the ./app2 directory
    build:
      context: ./app2
      dockerfile: Dockerfile
    # Expose port 5000 internally for Nginx to access
    expose:
      - "5000"
    # Assign app2 to our custom network
    networks:
      - webapp_network
    # Optional: Uncomment for Flask development server debugging
    # environment:
    #   FLASK_ENV: development

# Define a custom network for inter-container communication
networks:
  webapp_network:
    driver: bridge